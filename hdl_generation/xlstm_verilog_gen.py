"""
Verilog-A Generator for xLSTM Recurrent Structures
Extends PSI-HDL framework to support time-constant clustering and low-rank memory
"""

import torch
import numpy as np
from typing import Dict, List
import os


class XLSTMVerilogGenerator:
    """
    Generate Verilog-A code from compressed xLSTM models
    Supports both time-constant clustering and low-rank matrix memory
    """
    
    def __init__(self, model: torch.nn.Module, model_type: str = 'psi_xlstm'):
        """
        Initialize generator
        
        Args:
            model: Trained student model (ClusteringStudent or LowRankMLSTM)
            model_type: Type identifier for module naming
        """
        self.model = model
        self.model_type = model_type
        self.module_name = f"{model_type}_memristor"
        
    def generate_verilog_a(self, output_path: str) -> str:
        """
        Generate complete Verilog-A module
        
        Args:
            output_path: Path to save .va file
            
        Returns:
            verilog_code: Generated code string
        """
        print(f"Generating Verilog-A code for {self.model_type}...")
        
        code_parts = []
        code_parts.append(self._generate_header())
        code_parts.append(self._generate_module_declaration())
        code_parts.append(self._generate_parameters())
        code_parts.append(self._generate_state_variables())
        code_parts.append(self._generate_analog_block())
        code_parts.append(self._generate_footer())
        
        verilog_code = "\n".join(code_parts)
        
        # Save to file with UTF-8 encoding to handle special characters
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(verilog_code)
        
        print(f"Verilog-A module saved to {output_path}")
        return verilog_code
    
    def _generate_header(self) -> str:
        """Generate file header"""
        return f"""// Verilog-A Ψ-xLSTM Module for Memristor Modeling
// Auto-generated from compressed xLSTM network
// Model: {self.model_type}
// 
// This module implements a recurrent neural network with:
// - Clustered time constants for temporal dynamics
// - Low-rank matrix memory compression
// - Physics-informed structure discovery
//
// Generated by Ψ-xLSTM Framework

`include "constants.vams"
`include "disciplines.vams"
"""
    
    def _generate_module_declaration(self) -> str:
        """Generate module ports"""
        return f"""
module {self.module_name}(p, n);
    // Electrical ports
    inout p, n;
    electrical p, n;
    electrical internal_node;
    
    // Port descriptions
    // p: Positive terminal (voltage input)
    // n: Negative terminal (ground reference)
"""
    
    def _generate_parameters(self) -> str:
        """Generate parameters from trained model"""
        params = """
    // Model parameters (extracted from trained network)
    // Time constants (discovered via clustering)
"""
        
        # Extract time constants if available
        if hasattr(self.model, 'get_all_time_constants'):
            tau_dict = self.model.get_all_time_constants()
            for layer_name, tau_values in tau_dict.items():
                for i, tau in enumerate(tau_values):
                    params += f"    parameter real tau_{layer_name}_k{i} = {tau:.6e};\n"
        else:
            # Default time constants
            params += "    parameter real tau_0 = 1e-6;\n"
            params += "    parameter real tau_1 = 1e-5;\n"
            params += "    parameter real tau_2 = 1e-4;\n"
        
        params += "\n    // Network scaling parameters\n"
        params += "    parameter real V_scale = 1.0;\n"
        params += "    parameter real I_scale = 1e-3;\n"
        params += "\n    // Conductance parameters (from output layer)\n"
        params += "    parameter real G_on = 0.01;  // ON conductance (S)\n"
        params += "    parameter real G_off = 0.0001;  // OFF conductance (S)\n"
        
        return params
    
    def _generate_state_variables(self) -> str:
        """Generate state variable declarations"""
        variables = """
    // State variables (compressed representation)
    real state_0, state_1, state_2;  // Clustered temporal states
    real w_internal;  // Internal state variable (0 to 1)
    
    // Input/output variables
    real V_in;
    real I_out;
"""
        return variables
    
    def _generate_analog_block(self) -> str:
        """Generate main analog computation block with ddt() operators"""
        
        analog = """
    analog begin
        // Read input voltage
        V_in = V(p, n) / V_scale;
        
        // Initialize states at t=0
        @(initial_step) begin
            state_0 = 0.0;
            state_1 = 0.0;
            state_2 = 0.0;
            w_internal = 0.5;  // Mid-range initialization
        end
        
        // State evolution using discovered time constants
        // Implements: dw/dt = (input_forcing - w) / τ
        // Equation (6) from manuscript: clustered time constants
"""
        
        # Add time constant dynamics
        if hasattr(self.model, 'get_all_time_constants'):
            tau_dict = self.model.get_all_time_constants()
            for layer_idx, (layer_name, tau_values) in enumerate(tau_dict.items()):
                for k, tau in enumerate(tau_values):
                    state_var = f"state_{layer_idx}"
                    tau_param = f"tau_{layer_name}_k{k}"
                    
                    analog += f"""
        // Layer {layer_idx}, cluster {k}
        ddt({state_var}) <+ (tanh(V_in + {state_var}) - {state_var}) / {tau_param};
"""
        
        analog += """
        // Compute internal state variable (normalized 0-1)
        // Uses exponential gating as per xLSTM architecture
        w_internal = 0.5 * (1.0 + tanh(state_0 + 0.3 * state_1 + 0.1 * state_2));
        
        // Compute current from state-dependent conductance
        // I = V * G(w) where G(w) interpolates between G_on and G_off
        I_out = V_in * (w_internal * G_on + (1.0 - w_internal) * G_off) * I_scale;
        
        // Output current contribution
        I(p, n) <+ I_out;
    end
"""
        return analog
    
    def _generate_footer(self) -> str:
        """Generate module footer"""
        return "\nendmodule\n"
    
    def generate_testbench(self, output_path: str, 
                          V_min: float = -1.0, V_max: float = 1.0,
                          t_max: float = 1e-3, n_points: int = 1000) -> str:
        """
        Generate SPICE testbench for validation
        
        Args:
            output_path: Path to save .sp file
            V_min, V_max: Voltage sweep range
            t_max: Simulation time
            n_points: Number of time points
            
        Returns:
            testbench_code: Generated SPICE netlist
        """
        print(f"Generating SPICE testbench...")
        
        va_file = output_path.replace('.sp', '.va')
        
        tb = f"""* SPICE Testbench for Ψ-xLSTM Memristor Model
* Auto-generated by Ψ-xLSTM Framework
* Model: {self.model_type}

.title Psi-xLSTM Memristor Transient Simulation

* Include Verilog-A module
.hdl {va_file}

* Power supply
Vdd vdd 0 DC 5.0

* Input voltage source (transient waveform)
Vin p 0 PWL(
+  0ns {V_min}V
+  {t_max/4*1e9:.1f}ns {V_max}V
+  {t_max/2*1e9:.1f}ns {V_min}V
+  {t_max*3/4*1e9:.1f}ns {V_max}V
+  {t_max*1e9:.1f}ns 0V
+)

* Device under test
X1 p 0 {self.module_name}

* Load resistor
Rload p 0 1MEG

* Analysis
.tran {t_max/n_points*1e9:.3f}ns {t_max*1e9:.1f}ns

* Output
.print tran v(p) i(Vin)

* Control
.control
run
plot v(p) i(Vin)
wrdata {output_path.replace('.sp', '_results.dat')} v(p) i(Vin)
quit
.endc

.end
"""
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(tb)
        
        print(f"SPICE testbench saved to {output_path}")
        return tb
    
    def generate_hdl_package(self, output_dir: str) -> Dict[str, str]:
        """
        Generate complete HDL package
        
        Args:
            output_dir: Directory to save all files
            
        Returns:
            file_paths: Dictionary of generated file paths
        """
        os.makedirs(output_dir, exist_ok=True)
        
        file_paths = {}
        
        # Generate Verilog-A module
        va_path = os.path.join(output_dir, f"{self.module_name}.va")
        self.generate_verilog_a(va_path)
        file_paths['verilog_a'] = va_path
        
        # Generate testbench
        tb_path = os.path.join(output_dir, f"{self.module_name}_tb.sp")
        self.generate_testbench(tb_path)
        file_paths['testbench'] = tb_path
        
        # Generate parameter documentation
        doc_path = os.path.join(output_dir, f"{self.module_name}_params.txt")
        self._generate_parameter_doc(doc_path)
        file_paths['documentation'] = doc_path
        
        print(f"\nComplete HDL package generated in: {output_dir}")
        print(f"  - Verilog-A: {va_path}")
        print(f"  - Testbench: {tb_path}")
        print(f"  - Documentation: {doc_path}")
        
        return file_paths
    
    def _generate_parameter_doc(self, output_path: str):
        """Generate parameter documentation file"""
        doc = f"""Ψ-xLSTM Model Parameters
{'='*50}

Model: {self.model_type}
Generated: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Parameter Count:
  Total: {sum(p.numel() for p in self.model.parameters()):,}
"""
        
        if hasattr(self.model, 'count_parameters'):
            param_info = self.model.count_parameters()
            if isinstance(param_info, dict):
                doc += f"\nCompression Statistics:\n"
                for key, value in param_info.items():
                    if isinstance(value, (int, float)):
                        doc += f"  {key}: {value}\n"
        
        if hasattr(self.model, 'get_all_time_constants'):
            tau_dict = self.model.get_all_time_constants()
            doc += f"\nDiscovered Time Constants:\n"
            for layer_name, tau_values in tau_dict.items():
                doc += f"  {layer_name}:\n"
                for i, tau in enumerate(tau_values):
                    doc += f"    τ_{i} = {tau:.6e} s\n"
        
        doc += f"\nUsage in SPICE:\n"
        doc += f"  X1 pos neg {self.module_name}\n"
        doc += f"  + tau_layer_0_k0=<value>\n"
        doc += f"  + tau_layer_0_k1=<value>\n"
        doc += f"  + ...\n"
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(doc)


if __name__ == "__main__":
    print("Testing Verilog-A generation...")
    
    # Create a dummy model for testing
    from psi_xlstm.models.clustering_student import ClusteringStudent
    
    model = ClusteringStudent(hidden_size=32, num_layers=2, num_clusters=3)
    
    generator = XLSTMVerilogGenerator(model, model_type='psi_xlstm_test')
    
    # Generate HDL package
    file_paths = generator.generate_hdl_package('./test_hdl_output')
    
    print("\nGeneration test completed!")